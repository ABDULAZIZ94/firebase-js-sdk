/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  Metadata,
  GrpcObject,
  credentials as GrpcCredentials,
  ServiceError
} from '@grpc/grpc-js';
import * as grpcPkgJson from '@grpc/grpc-js/package.json';

import firebase from '@firebase/app';
const SDK_VERSION = firebase.SDK_VERSION;

const grpcVersion = grpcPkgJson.version;

import { Token } from '../api/credentials';
import { DatabaseInfo } from '../core/database_info';
import { Connection, Stream } from '../remote/connection';
import { mapCodeFromRpcCode } from '../remote/rpc_error';
import { StreamBridge } from '../remote/stream_bridge';
import { hardAssert } from '../util/assert';
import { FirestoreError } from '../util/error';

import { NodeCallback, nodePromise } from '../util/node_api';
import { Deferred } from '../util/promise';

const LOG_TAG = 'Connection';

// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because
// we are doing out-of-band releases. Once we release as part of Firebase, we
// should use the Firebase version instead.
const X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;

function createMetadata(
  databaseInfo: DatabaseInfo,
  token: Token | null
): Metadata {
  hardAssert(
    token === null || token.type === 'OAuth',
    'If provided, token must be OAuth'
  );

  const metadata = new Metadata();
  if (token) {
    for (const header in token.authHeaders) {
      if (token.authHeaders.hasOwnProperty(header)) {
        metadata.set(header, token.authHeaders[header]);
      }
    }
  }
  metadata.set('x-goog-api-client', X_GOOG_API_CLIENT_VALUE);
  // This header is used to improve routing and project isolation by the
  // backend.
  metadata.set(
    'google-cloud-resource-prefix',
    `projects/${databaseInfo.databaseId.projectId}/` +
      `databases/${databaseInfo.databaseId.database}`
  );
  return metadata;
}

// The type of these stubs is dynamically generated by the GRPC runtime
// from the protocol buffer.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type GeneratedGrpcStub = any;

/**
 * A Connection implemented by GRPC-Node.
 */
export class GrpcConnection implements Connection {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private firestore: any;

  // We cache stubs for the most-recently-used token.
  private cachedStub: GeneratedGrpcStub | null = null;

  constructor(protos: GrpcObject, private databaseInfo: DatabaseInfo) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.firestore = (protos as any)['google']['firestore']['v1'];
  }

  private ensureActiveStub(): GeneratedGrpcStub {
    if (!this.cachedStub) {
      const credentials = this.databaseInfo.ssl
        ? GrpcCredentials.createSsl()
        : GrpcCredentials.createInsecure();
      this.cachedStub = new this.firestore.Firestore(
        this.databaseInfo.host,
        credentials
      );
    }
    return this.cachedStub;
  }

  invokeRPC<Req, Resp>(
    rpcName: string,
    request: Req,
    token: Token | null
  ): Promise<Resp> {
    const stub = this.ensureActiveStub();
    const metadata = createMetadata(this.databaseInfo, token);

    return nodePromise((callback: NodeCallback<Resp>) => {
      return stub[rpcName](
        request,
        metadata,
        (grpcError?: ServiceError, value?: Resp) => {
          if (grpcError) {
            callback(
              new FirestoreError(
                mapCodeFromRpcCode(grpcError.code),
                grpcError.message
              )
            );
          } else {
            callback(undefined, value);
          }
        }
      );
    });
  }

  invokeStreamingRPC<Req, Resp>(
    rpcName: string,
    request: Req,
    token: Token | null
  ): Promise<Resp[]> {
    const results: Resp[] = [];
    const responseDeferred = new Deferred<Resp[]>();

    const stub = this.ensureActiveStub();
    const metadata = createMetadata(this.databaseInfo, token);
    const stream = stub[rpcName](request, metadata);
    stream.on('data', (response: Resp) => {
      results.push(response);
    });
    stream.on('end', () => {
      responseDeferred.resolve(results);
    });
    stream.on('error', (grpcError: ServiceError) => {
      const code = mapCodeFromRpcCode(grpcError.code);
      responseDeferred.reject(new FirestoreError(code, grpcError.message));
    });

    return responseDeferred.promise;
  }

  // TODO(mikelehen): This "method" is a monster. Should be refactored.
  openStream<Req, Resp>(
    rpcName: string,
    token: Token | null
  ): Stream<Req, Resp> {
    const stub = this.ensureActiveStub();
    const metadata = createMetadata(this.databaseInfo, token);
    const grpcStream = stub[rpcName](metadata);

    let closed = false;
    const close = (err?: FirestoreError): void => {
      if (!closed) {
        closed = true;
        stream.callOnClose(err);
        grpcStream.end();
      }
    };

    const stream = new StreamBridge<Req, Resp>({
      sendFn: (msg: Req) => {
        if (!closed) {
          try {
            grpcStream.write(msg);
          } catch (e) {
            // This probably means we didn't conform to the proto.  Make sure to
            // log the message we sent.
            throw e;
          }
        } else {
        }
      },
      closeFn: () => {
        close();
      }
    });

    grpcStream.on('data', (msg: Resp) => {
      if (!closed) {
        stream.callOnMessage(msg);
      }
    });

    grpcStream.on('end', () => {
      close();
    });

    grpcStream.on('error', (grpcError: ServiceError) => {
      const code = mapCodeFromRpcCode(grpcError.code);
      close(new FirestoreError(code, grpcError.message));
    });

    // TODO(dimond): Since grpc has no explicit open status (or does it?) we
    // simulate an onOpen in the next loop after the stream had it's listeners
    // registered
    setTimeout(() => {
      stream.callOnOpen();
    }, 0);

    return stream;
  }
}
